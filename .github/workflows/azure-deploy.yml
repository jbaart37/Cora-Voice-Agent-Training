name: Deploy to Azure

on:
  workflow_dispatch:
    inputs:
      environment_name:
        description: 'Environment name (e.g., dev, prod, test)'
        required: true
        default: 'dev'
      location:
        description: 'Azure region'
        required: true
        default: 'eastus'
        type: choice
        options:
          - eastus
          - eastus2
          - westus2
          - westeurope
          - northeurope
      resource_group_name:
        description: 'Resource group name (leave empty to auto-generate based on environment name)'
        required: false
        default: ''

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-22.04
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v2
        with:
          creds: '{"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}"}'

      - name: Verify Service Principal Permissions
        run: |
          echo "ğŸ” Checking if service principal has required permissions..."
          
          # Check if service principal has User Access Administrator role
          ROLE_CHECK=$(az role assignment list \
            --assignee ${{ secrets.AZURE_CLIENT_ID }} \
            --scope /subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }} \
            --query "[?roleDefinitionName=='User Access Administrator']" \
            --output tsv)
          
          if [ -z "$ROLE_CHECK" ]; then
            echo "âŒ ERROR: Service principal is missing 'User Access Administrator' role"
            echo ""
            echo "The deployment requires this role to assign Storage Data Contributor permissions"
            echo "to the Container App's managed identity during infrastructure provisioning."
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ”§ REQUIRED ONE-TIME SETUP:"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            echo "Run this command ONCE to grant the required permission:"
            echo ""
            echo "  az role assignment create \\"
            echo "    --assignee ${{ secrets.AZURE_CLIENT_ID }} \\"
            echo "    --role 'User Access Administrator' \\"
            echo "    --scope /subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            echo "Note: This is a one-time setup. After granting this permission,"
            echo "all future deployments will work automatically."
            echo ""
            exit 1
          fi
          
          echo "âœ… Service principal has required permissions"
          echo "   Role: User Access Administrator"
          echo "   Scope: Subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}"
        shell: bash

      - name: Provision with Azure CLI (bypass azd bug)
        id: provision
        working-directory: ${{ github.workspace }}
        run: |
          echo "Provisioning Azure resources using Azure CLI directly (bypassing azd v1.22.5 bug)..."
          
          DEPLOYMENT_NAME="voiceagent-$(date +%Y%m%d-%H%M%S)"
          
          # Determine resource group name
          RG_NAME="${{ github.event.inputs.resource_group_name }}"
          if [ -z "$RG_NAME" ]; then
            RG_NAME="rg-${{ github.event.inputs.environment_name }}"
          fi
          
          echo "Deploying to subscription: ${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          echo "Resource group: $RG_NAME"
          echo "Deployment name: $DEPLOYMENT_NAME"
          
          # Auto-derive Azure OpenAI resource ID from endpoint URL
          echo "Deriving Azure OpenAI resource ID from endpoint..."
          OPENAI_ENDPOINT="${{ secrets.AZURE_OPENAI_ENDPOINT }}"
          # Extract account name (everything before first dot after https://)
          OPENAI_ACCOUNT_NAME=$(echo "$OPENAI_ENDPOINT" | sed 's|https://||' | cut -d'.' -f1)
          echo "Azure OpenAI account name: $OPENAI_ACCOUNT_NAME"
          
          OPENAI_RESOURCE_ID=$(az cognitiveservices account list \
            --subscription "${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
            --query "[?name=='$OPENAI_ACCOUNT_NAME'].id" -o tsv)
          
          if [ -z "$OPENAI_RESOURCE_ID" ]; then
            echo "âš ï¸ Warning: Could not find Azure OpenAI account '$OPENAI_ACCOUNT_NAME'. RBAC assignment will be skipped."
          else
            echo "Azure OpenAI resource ID: $OPENAI_RESOURCE_ID"
          fi
          
          # Pre-create resource group to avoid ARM deployment errors
          echo "Creating resource group if it doesn't exist..."
          az group create --name "$RG_NAME" --location "${{ github.event.inputs.location }}"
          
          # Deploy Bicep template using Azure CLI
          set +e  # Don't exit on error, capture it
          az deployment sub create \
            --name "$DEPLOYMENT_NAME" \
            --location "${{ github.event.inputs.location }}" \
            --template-file infra/main.bicep \
            --parameters environmentName="${{ github.event.inputs.environment_name }}" \
            --parameters location="${{ github.event.inputs.location }}" \
            --parameters azureOpenAIEndpoint="${{ secrets.AZURE_OPENAI_ENDPOINT }}" \
            --parameters modelName="${{ secrets.AZURE_OPENAI_MODEL_NAME }}" \
            --parameters resourceGroupName="$RG_NAME" \
            --parameters azureOpenAIResourceId="$OPENAI_RESOURCE_ID"
          
          DEPLOY_EXIT_CODE=$?
          set -e
          
          if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
            echo "âŒ Deployment failed! Getting detailed error information..."
            echo "=== Subscription-level deployment operations ==="
            az deployment operation sub list --name "$DEPLOYMENT_NAME" --query '[].properties.{resource:targetResource.resourceName, status:provisioningState, error:statusMessage.error}' -o json || true
            echo "=== Detailed resource group deployment operations ==="
            az deployment operation group list --resource-group "$RG_NAME" --name "container-apps-environment" --query '[].properties.statusMessage' -o json || true
            echo "=== All operations in resource group ==="
            az deployment operation group list --resource-group "$RG_NAME" --query '[].{operation:properties.targetResource.resourceName, status:properties.provisioningState}' -o table || true
            exit 1
          fi
          
          echo "âœ… Provisioning completed successfully!"
          
          # Get outputs from deployment - with detailed debugging
          echo "=== Fetching deployment outputs ==="
          OUTPUTS=$(az deployment sub show --name "$DEPLOYMENT_NAME" --query properties.outputs -o json)
          echo "Raw outputs: $OUTPUTS"
          
          # Extract values with case-insensitive jq queries (Azure ARM changes output casing)
          CONTAINER_REGISTRY=$(echo "$OUTPUTS" | jq -r 'to_entries | map(select(.key | ascii_downcase == "azure_container_registry_name")) | .[0].value.value // empty')
          RESOURCE_GROUP=$(echo "$OUTPUTS" | jq -r 'to_entries | map(select(.key | ascii_downcase == "azure_resource_group")) | .[0].value.value // empty')
          WEB_URI=$(echo "$OUTPUTS" | jq -r 'to_entries | map(select(.key | ascii_downcase == "web_uri")) | .[0].value.value // empty')
          STORAGE_ACCOUNT=$(echo "$OUTPUTS" | jq -r 'to_entries | map(select(.key | ascii_downcase == "azure_storage_account_name")) | .[0].value.value // empty')
          APP_INSIGHTS_CONN_STRING=$(echo "$OUTPUTS" | jq -r 'to_entries | map(select(.key | ascii_downcase == "applicationinsights_connection_string")) | .[0].value.value // empty')
          
          # Fallback to resource group name if not in outputs
          if [ -z "$RESOURCE_GROUP" ]; then
            RESOURCE_GROUP="$RG_NAME"
          fi
          
          echo "Deployment outputs:"
          echo "  Container Registry: $CONTAINER_REGISTRY"
          echo "  Resource Group: $RESOURCE_GROUP"
          echo "  Web URI: $WEB_URI"
          echo "  Storage Account: $STORAGE_ACCOUNT"
          echo "  App Insights: ${APP_INSIGHTS_CONN_STRING:0:50}..." # Truncate for security
          
          # Validate we have required outputs
          if [ -z "$CONTAINER_REGISTRY" ] || [ "$CONTAINER_REGISTRY" == "null" ]; then
            echo "âŒ ERROR: Failed to get Container Registry name from deployment outputs"
            echo "Attempting to find registry in resource group..."
            CONTAINER_REGISTRY=$(az acr list --resource-group "$RG_NAME" --query '[0].name' -o tsv)
            echo "  Found registry: $CONTAINER_REGISTRY"
          fi
          
          if [ -z "$STORAGE_ACCOUNT" ] || [ "$STORAGE_ACCOUNT" == "null" ]; then
            echo "âš ï¸  WARNING: Failed to get Storage Account from deployment outputs"
            echo "Attempting to find storage account in resource group..."
            STORAGE_ACCOUNT=$(az storage account list --resource-group "$RG_NAME" --query '[0].name' -o tsv)
            echo "  Found storage account: $STORAGE_ACCOUNT"
          fi
          
          if [ -z "$APP_INSIGHTS_CONN_STRING" ] || [ "$APP_INSIGHTS_CONN_STRING" == "null" ]; then
            echo "âš ï¸  WARNING: Failed to get App Insights connection string from deployment outputs"
            echo "Attempting to find App Insights in resource group..."
            APP_INSIGHTS_CONN_STRING=$(az monitor app-insights component show --resource-group "$RG_NAME" --query '[0].connectionString' -o tsv)
            echo "  Found App Insights connection string"
          fi
          
          if [ -z "$WEB_URI" ] || [ "$WEB_URI" == "null" ]; then
            echo "âš ï¸  WARNING: Failed to get Web URI from deployment outputs"
            echo "Attempting to find Container App in resource group..."
            WEB_URI=$(az containerapp list --resource-group "$RG_NAME" --query '[0].properties.configuration.ingress.fqdn' -o tsv)
            if [ -n "$WEB_URI" ]; then
              WEB_URI="https://$WEB_URI"
              echo "  Found Web URI: $WEB_URI"
            fi
          fi
          
          # Export for next steps (must be non-empty)

          echo "CONTAINER_REGISTRY=$CONTAINER_REGISTRY" >> $GITHUB_OUTPUT
          echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "WEB_URI=$WEB_URI" >> $GITHUB_OUTPUT
          echo "STORAGE_ACCOUNT=$STORAGE_ACCOUNT" >> $GITHUB_OUTPUT
          echo "APP_INSIGHTS_CONN_STRING=$APP_INSIGHTS_CONN_STRING" >> $GITHUB_OUTPUT
        env:
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Build and deploy container application
        working-directory: ${{ github.workspace }}
        run: |
          echo "Building and deploying container application..."
          
          CONTAINER_REGISTRY="${{ steps.provision.outputs.CONTAINER_REGISTRY }}"
          RESOURCE_GROUP="${{ steps.provision.outputs.RESOURCE_GROUP }}"
          WEB_URI="${{ steps.provision.outputs.WEB_URI }}"
          STORAGE_ACCOUNT="${{ steps.provision.outputs.STORAGE_ACCOUNT }}"
          APP_INSIGHTS_CONN_STRING="${{ steps.provision.outputs.APP_INSIGHTS_CONN_STRING }}"
          
          echo "Container Registry: $CONTAINER_REGISTRY"
          echo "Resource Group: $RESOURCE_GROUP"
          echo "Storage Account: $STORAGE_ACCOUNT"
          
          # Login to Azure Container Registry
          echo "Logging in to ACR..."
          az acr login --name "$CONTAINER_REGISTRY"
          
          # Build and push container image
          echo "Building container image..."
          IMAGE_TAG="$CONTAINER_REGISTRY.azurecr.io/voice-agent:${{ github.sha }}"
          
          docker build -t "$IMAGE_TAG" ./src
          
          echo "Pushing image to ACR..."
          docker push "$IMAGE_TAG"
          
          # Find the Container App name (it's based on resource token from Bicep)
          CONTAINER_APP=$(az containerapp list --resource-group "$RESOURCE_GROUP" --query '[0].name' -o tsv)
          
          echo "Container App name: $CONTAINER_APP"
          
          # Update Container App with new image and environment variables
          echo "Updating Container App with new image and configuration..."
          az containerapp update \
            --name "$CONTAINER_APP" \
            --resource-group "$RESOURCE_GROUP" \
            --image "$IMAGE_TAG" \
            --replace-env-vars \
              AZURE_AI_FOUNDRY_ENDPOINT=${{ secrets.AZURE_OPENAI_ENDPOINT }} \
              AZURE_AI_MODEL_NAME=${{ secrets.AZURE_OPENAI_MODEL_NAME }} \
              FLASK_ENV=production \
              AZURE_STORAGE_ACCOUNT_NAME=$STORAGE_ACCOUNT \
              APPLICATIONINSIGHTS_CONNECTION_STRING="$APP_INSIGHTS_CONN_STRING"
      - name: Display deployment summary
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ‰ Deployment Complete!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ“¦ Application URL:"
          echo "   ${{ steps.provision.outputs.WEB_URI }}"
          echo ""
          echo "ğŸ“Š Resource Group:"
          echo "   ${{ steps.provision.outputs.RESOURCE_GROUP }}"
          echo ""
          echo "ğŸ³ Container Registry:"
          echo "   ${{ steps.provision.outputs.CONTAINER_REGISTRY }}.azurecr.io"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
